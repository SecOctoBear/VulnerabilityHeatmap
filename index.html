<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Heatmap PoC</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
</head>

<body>
  <div class="container">
    <h1>Threadfix Heatmap Visualization</h1>
    <p>More heatmap options can be found: <a
        href="https://apexcharts.com/javascript-chart-demos/heatmap-charts/basic/">here</a></p>

    <form id="form">
      <div class="row">
        <div class="mb-3 col">
          <label for="start_date" class="form-label">Start Date</label>
          <input type="date" class="form-control" id="start_date" name="start_date">
        </div>

        <div class="mb-3 col">
          <label for="end_date" class="form-label">End Date</label>
          <input type="date" class="form-control" id="end_date">
        </div>
      </div>

      <div class="row">
        <div class="mb-3 col">
          <label for="factor_info" class="form-label">factor_info</label>
          <input type="number" class="form-control" id="factor_info" value="0.5">
        </div>
        <div class="mb-3 col">
          <label for="factor_low" class="form-label">factor_low</label>
          <input type="number" class="form-control" id="factor_low" value="1">
        </div>
        <div class="mb-3 col">
          <label for="factor_medium" class="form-label">factor_medium</label>
          <input type="number" class="form-control" id="factor_medium" value="3">
        </div>
        <div class="mb-3 col">
          <label for="factor_high" class="form-label">factor_high</label>
          <input type="number" class="form-control" id="factor_high" value="10">
        </div>
        <div class="mb-3 col">
          <label for="factor_critical" class="form-label">factor_critical</label>
          <input type="number" class="form-control" id="factor_critical" value="40">
        </div>
      </div>
      <!-- https://community.tenable.com/s/article/Vulnerability-Weight-and-Scores-->

      <div class="row">
        <div class="mb-3 col">
          <label for="minimum_scans" class="form-label">Minimum scans</label>
          <input type="number" class="form-control" id="minimum_scans" value="10" min="10">
        </div>
        <div class="mb-3 col">
          <label for="minimum_days" class="form-label">Minimum days</label>
          <input type="number" class="form-control" id="minimum_days" value="10" min="10">
        </div>
      </div>

      <!-- TODO: READ THE F**** REQS!!!!!!!!!!!!!!!! -->

      <div class="mb-3">
        <label for="scanner" class="form-label">Scanner</label>
        <select class="form-select" id="scanner" multiple>
          <option selected>All</option>
          <option>Kiuwan</option>
          <option>Acunetix</option>
          <option>Trivy</option>
          <option>IriusRisk</option>
        </select>
      </div>

      <div id="weighted_criticality"></div>

      <button id="submit" class="btn btn-primary">Init chart</button>
      <button id="export" class="btn btn-secondary">Export(TODO?)</button>
     <!--<pre>
            TODO:
        number of required scans by all tools performed > minimum_scans AND last scan across all tools < minimum_days) == TRUE 
        weighted_criticality = (Critical*factorCritical + High* factorHigh + Medium* factorMedium + Low* factorLow + Info* factorInfo
      </pre>--> 
    </form>
    <div id="heatmap"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/locale/de.min.js"></script>

  <script>
    if (!document.getElementById('start_date').value) {
      document.getElementById('start_date').value = new Date().toISOString().substr(0, 10);
    }
    if (!document.getElementById('end_date').value) {
      document.getElementById('end_date').value = moment().add(1, 'M').toISOString().substr(0, 10);
    }

    const config = {}
    const form = document.getElementById('form');
    form.addEventListener('submit', (event) => {
      event.preventDefault();

      const formData = new FormData(event.target);
      const formProps = Object.fromEntries(formData);

      // console.log(formData, formProps);

      config.minScans = document.getElementById('minimum_scans').value
      config.minDays = document.getElementById('minimum_days').value
      config.startDate = document.getElementById('start_date').value

      config.factor_info = document.getElementById('factor_info').value
      config.factor_low = document.getElementById('factor_low').value
      config.factor_medium = document.getElementById('factor_medium').value
      config.factor_high = document.getElementById('factor_high').value
      config.factor_critical = document.getElementById('factor_critical').value
      
      console.log('init with config ', config)
      initHeatmap()
    });

    function setLoading(loading) {
      document.querySelector("#heatmap").innerHTML = loading
    }
    function initHeatmap() {
      setLoading('loading...')

      // Fetch data from the node.js server, returns a promise with json data
      function fetchData() {
        return fetch('http://10.109.64.133:9876/', {
          method: "GET"
        }).then(function (response) {
          return response.json()
        }, function (error) {
          console.log("ERRORRRRRRRRRRR", error.message); //=> String
        })
      }

      fetchData()
        .then(function (data) {
          console.log(data)
          const APPS = data.object
          const series = []

          let i = 0
          for (app of APPS) {
            console.log("app: ", app, app.scans.length)

            series.push({
              id: app.uniqueId,
              name: app.name,
              data: generateData(app)
            })

            // TODO: how many (which) apps?
            if (i++ > 1)
              break
          }

          setLoading('')

          let options = {
            series: series, // array for the data
            chart: {
              //height: 350,
              type: 'heatmap',
            },
            dataLabels: {
              formatter: function (val, opts) {
                //console.log(val, opts)
                const seriesValue = series[opts.seriesIndex]
                // const dataOfSeriesValue = seriesValue.data[opts.dataPointIndex]
                const app = APPS.find((app) => { return app.uniqueId === seriesValue.id })
                //console.log("YES",seriesValue.name,  app)
                const scan = app.scans[opts.dataPointIndex]
                return [
                  'Critical: ' + scan.numberCriticalVulnerabilities + ' High: ' + scan.numberHighVulnerabilities,
                  'Medium: ' + scan.numberMediumVulnerabilities + ' Low: ' + scan.numberLowVulnerabilities,
                ];
              },
              //offsetY: -15,
              style: {
                fontSize: "8px",
              },
            },
            // REQ: The fields of the heat map should be colored depending on the defined thresholds for application vulnerabilities. 
            colors: [],
            title: {
              text: 'Threadfix HeatMap Chart'
            },
          };

          // add these functions dynamically based on the number of calendar weeks (x axis) !
          // Docs: "Note that the number of items in colors array should be equal to number of series if you intend to provide a function for it."
          // https://apexcharts.com/docs/options/colors/
          options.colors = []
          for (let i = 0; i < 10; i++) {
            options.colors.push(function ({ value, seriesIndex, w }) {
              console.log("COLORS", value, seriesIndex);
              // TODO
                /*Following colors should be applied (depending on definied threshholds): 
                Blue (no information available) #002dee
                Light Green (weighted_criticality < th1) 0df31e
                Dark Green (th1 < weighted_criticality < th2) 008000
                Yellow (th2 < weighted_criticality < th3) FFFF00
                Orange  (th3 < weighted_criticality < th4) FF7F00
                Red (th4 < weighted_criticality < th5)  FF0000
                Dark-Red (th5 < weighted_criticality) a71a17
                */
              return '#a71a17'
            })
          }

          // options.colors = ['#ff0000']

          var chart = new ApexCharts(document.querySelector("#heatmap"), options);
          chart.render();
          /*chart.updateSeries([{
              name: 'Sales',
              data: response.data
          }])*/
        })

      function generateData(app) {
        const yrange = {
          min: 0,
          max: 90
        }

        /*for (scan of app.scans) {
          console.log(moment(scan.importTime).week(), scan.importTime, new Date(scan.importTime))
        }*/

        var i = 0;
        var series = [];
        while (i < 10) { // ?
          const scan = app.scans[i]
          if (!scan)
            break
          //console.log(scan)
          var x = 'CW' + i + '(todo)'

          let weighted_criticality = scan.numberClosedVulnerabilities;
          /*
          IF  
          loop all scanners (number of required scans by all tools performed > minimum_scans AND last scan across all tools < minimum_days) == TRUE 
            weighted_criticality = (Critical*factorCritical + High* factorHigh + Medium* factorMedium + Low* factorLow + Info* factorInfo)  
          ELSE 
            weighted_criticality = -1 
          */

          var y = weighted_criticality // Math.floor(Math.random() * (yrange.max - yrange.min + 1)) + yrange.min;

          series.push({
            x: x,
            y: y
          });

          i++;
        }
        return series;
      }
    }

  </script>
</body>

</html>